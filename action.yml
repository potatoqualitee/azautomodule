name: "azautomodule"
branding:
  icon: "terminal"
  color: "blue"
description: "Imports a PowerShell-based GitHub Repo module into Azure Automation"
inputs:
  module-name:
    description: "The name of the module that this action imports. Defaults to the repository name."
    required: false
  module-uri:
    description: "The url to a module zip package. Defaults to GitHub's branch zip."
    required: false
  module-path:
    description: "If the module is somewhere in the local directory, use the path."
    required: false
  module-version:
    description: "Specifies the version of the module to which this action updates Automation. If no version is specified and it's required, the action will attempt to figure it out."
    required: false
  resource-group-name:
    description: "Specifies the name of a resource group for which this action imports the module."
    required: true
  automation-account-name:
    description: "The name of the Automation account for which this action imports the module"
    required: true
  default-profile:
    description: "The credentials, account, tenant, and subscription used for communication with Azure."
    required: false
  verbose:
    description: "Show verbose output. Defaults to true."
    required: true
    default: "true"
runs:
  using: "composite"
  steps:
    - name: Install and cache PowerShell modules
      uses: potatoqualitee/psmodulecache@v5.2
      with:
        modules-to-cache: Az.Automation, Az.Accounts
    - id: module
      shell: pwsh
      run: |
        # First check to see if they've logged into Azure
        if (-not (Get-AzContext).Account) {
          throw "Please use the Azure Login GitHub Action to login first. See the azautomodule readme for details."
        }

        # Explicit import before verbose because implicit imports are so noisy
        Import-Module Az.Automation

        if ("${{ inputs.verbose }}" -eq $true) {
          $VerbosePreference = "Continue"
        }

        $branch = $env:GITHUB_REF_NAME
        Write-Output "Currently in branch: $branch"
        $resourcegroup = "${{ inputs.resource-group-name }}"
        $account = "${{ inputs.automation-account-name }}"

        if (-not "${{ inputs.module-name }}") {
          $modulename = $env:GITHUB_REPOSITORY -split "/" | Select-Object -Last 1
        } else {
          $modulename = "${{ inputs.module-name }}"
        }

        $modulepath = ${{ inputs.module-path }}
        $tempdir = Join-Path -Path ([System.IO.Path]::GetTempPath()) -ChildPath $modulename
        $null = New-Item -Type Directory -Path $tempdir
        $tempzip = Join-Path -Path $tempdir -ChildPath "$branch.zip"
        $zip = Join-Path -Path $tempdir -ChildPath "$modulename.zip"

        if (-not $modulepath) {
          if (-not "${{ inputs.module-uri }}") {
            $moduleuri = "https://github.com/$env:GITHUB_REPOSITORY/archive/refs/heads/$branch.zip"
          } else {
            $moduleuri = "${{ inputs.module-uri }}"
          }
          $null = Invoke-WebRequest -Uri $moduleuri -OutFile $tempzip -ErrorAction Stop

          if ($IsLinux -or $IsMacos) {
            Import-Module "${{ github.action_path }}/sample/archive.psm1"
          }
          Expand-Archive -Path $tempzip -DestinationPath $tempdir
          # change directory to wherever it's at
          Set-Location -Path (Get-ChildItem -Directory $tempdir).FullName
        } else {
          # Help them out in case they specified a psm1 or psd1
          if ((Get-Item -Path $modulepath).PSIsContainer) {
            Set-Location -Path $modulepath
          } else {
            Set-Location -Path (Split-Path $modulepath)
          }
        }
        Compress-Archive -Path . -DestinationPath $zip -Force

        $gist = "temp for azure automation" | gh gist create --public
        $gistid = Split-Path -path $gist -Leaf


        git config remote.origin.url ('https://${{secrets.GITHUB_TOKEN}}@gist.github.com/' + "$gistid.git")
        git config user.name temp
        git config user.email temp@temp.com
        git clone ('https://${{secrets.GITHUB_TOKEN}}@gist.github.com/' + "$gistid.git")


        Copy-Item -Path $zip -Destination $gistid/
        Set-Location -Path $gistid
        git add (Split-Path -Path $zip -Leaf)
        git commit -m "added from azure automation"
        git push origin main

        return

        $getparms = @{
          Name                  = $modulename
          ResourceGroupName     = $resourcegroup
          AutomationAccountName = $account
          ErrorAction           = "Ignore"
        }

        Get-AzAutomationModule @getparms -OutVariable moduleinstance

        if ($moduleinstance.ProvisioningState -eq "Creating") {
          Write-Warning "The $modulename module is still importing into Azure Automation. Waiting until it's finished before moving on..."
          do {
            Start-Sleep 3
            Write-Warning "Waiting..."
          } while ((Get-AzAutomationModule @getparms).ProvisioningState -eq "Creating")
        }

        $parms = @{
          Name                  = $modulename
          ResourceGroupName     = $resourcegroup
          AutomationAccountName = $account
          ContentLinkUri        = $moduleuri
        }

        if ("${{ inputs.default-profile }}") {
          $parms.DefaultProfile = "${{ inputs.default-profile }}"
        }

        if (-not $moduleinstance) {
          $remove = $true
          New-AzAutomationModule @parms
        } else {
          if ("${{ inputs.module-version }}") {
            $parms.ContentLinkVersion = "${{ inputs.module-version }}"
          } else {
            $parms.ContentLinkVersion = "2.0"
          }
          Set-AzAutomationModule @parms
        }

        # It sometimes takes a while...
        do {
          Start-Sleep 5
          Write-Output "Module import is in progress.."
        } while ((Get-AzAutomationModule @getparms).ProvisioningState -in "Creating", "RunningImportModuleRunbook", "ContentValidated")

        # Finish and if it's anything other than Available, the import was not successful
        Get-AzAutomationModule @getparms -OutVariable results
        $state = $results.ProvisioningState

        # If it was newly added
        if ($remove) {
          $null = $results | Remove-AzAutomationModule -Force
        }
        if ($state -ne "Available") {
          throw "Provisioning failed with status $state"
        }