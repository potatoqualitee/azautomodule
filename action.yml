name: "azautomodule"
branding:
  icon: "terminal"
  color: "blue"
description: "Imports a PowerShell-based GitHub Repo module into Azure Automation"
inputs:
  module-name:
    description: "The name of the module that this action imports. Defaults to the repository name."
    required: false
  module-uri:
    description: "The url to a module zip package. Defaults to GitHub's branch zip."
    required: false
  module-path:
    description: "If the module is somewhere in the local directory, use the path."
    required: false
  module-version:
    description: "Specifies the version of the module to which this action updates Automation. If no version is specified and it's required, the action will attempt to figure it out."
    required: false
  resource-group-name:
    description: "Specifies the name of a resource group for which this action imports the module."
    required: true
  automation-account-name:
    description: "The name of the Automation account for which this action imports the module"
    required: true
  default-profile:
    description: "The credentials, account, tenant, and subscription used for communication with Azure."
    required: false
  verbose:
    description: "Show verbose output. Defaults to true."
    required: true
    default: "true"
runs:
  using: "composite"
  steps:
    - name: Install and cache PowerShell modules
      uses: potatoqualitee/psmodulecache@v5.2
      with:
        modules-to-cache: Az.Automation, Az.Accounts

    - id: module
      shell: pwsh
      run: |
        # First check to see if they've logged into Azure
        if (-not (Get-AzContext).Account) {
          throw "Please use the Azure Login GitHub Action to login first. See the azautomodule readme for details."
        }

        if (-not $env:GITHUB_TOKEN) {
          throw "Please set a GITHUB_TOKEN environmental variable using a PAT. See the azautomodule readme for details."
        }

        # Explicit import before verbose because implicit imports are so noisy
        Import-Module Az.Automation

        if ("${{ inputs.verbose }}" -eq $true) {
          $VerbosePreference = "Continue"
        }

        $branch = $env:GITHUB_REF_NAME
        Write-Verbose "Currently in branch: $branch"
        $resourcegroup = "${{ inputs.resource-group-name }}"
        $account = "${{ inputs.automation-account-name }}"

        if (-not "${{ inputs.module-name }}") {
          $modulename = $env:GITHUB_REPOSITORY -split "/" | Select-Object -Last 1
        } else {
          $modulename = "${{ inputs.module-name }}"
        }

        Write-Verbose "Starting directory: $pwd"
        $modulepath = "${{ inputs.module-path }}"
        $usertemp = [System.IO.Path]::GetTempPath()
        $tempzip = Join-Path -Path $usertemp -ChildPath "branch$branch.zip"

        #ultimately what will be zipped
        $finalmoduledir = Join-Path -Path $usertemp -ChildPath $modulename

        if (-not $modulepath) {
          Write-Verbose "Not modulepath"
          if (-not "${{ inputs.module-uri }}") {
            $moduleuri = "https://github.com/$env:GITHUB_REPOSITORY/archive/refs/heads/$branch.zip"
          } else {
            $moduleuri = "${{ inputs.module-uri }}"
          }

          Write-Verbose "Module Uri: $moduleuri"
          $null = Invoke-WebRequest -Uri $moduleuri -OutFile $tempzip -ErrorAction Stop
          Get-ChildItem -Path $tempzip | Write-Verbose

          # Got the zip, now extract
          New-Item -Type Directory -Path $finalmoduledir | Write-Verbose

          if ($IsLinux -or $IsMacos) {
            unzip $tempzip $finalmoduledir
          } else {
            Expand-Archive -Path $tempzip -DestinationPath $finalmoduledir -Force
          }
        } else {
          Write-Verbose "Found modulepath: $modulepath"
          # Help them out in case they specified a psm1 or psd1
          if ((Get-Item -Path $modulepath).PSIsContainer) {
            Set-Location -Path $modulepath
          } else {
            Set-Location -Path (Split-Path $modulepath)
          }
          if ($IsLinux -or $IsMacos) {
            cp -R * "$finalmoduledir/"
          } else {
            Get-ChildItem -Path $pwd | Copy-Item -Recurse -Destination "$finalmoduledir/"
          }
        }

        Write-Verbose "Current directory: $pwd"
        $zip = Join-Path -Path $usertemp -ChildPath temp.zip
        $psd1directory = Get-ChildItem -Path $pwd -Recurse | Where-Object Extension -match ".psm1|.psd1" | Select-Object -First 1 -ExpandProperty DirectoryName
        Set-Location -Path $psd1directory
        Write-Verbose "Current directory: $pwd"
        Get-ChildItem -Recurse | Write-Warning
        Compress-Archive -Path . -DestinationPath $zip -Force -ErrorAction Stop

        # Upload to accessible web address. The portal uploads
        # to storage, we'll upload to gist.github.com
        $gist = "temp for azure automation" | gh gist create
        $gistid = Split-Path -path $gist -Leaf
        gh gist clone $gistid

        Copy-Item -Path $zip -Destination $gistid/
        Set-Location -Path $gistid
        git config remote.origin.url "https://$env:GITHUB_TOKEN@gist.github.com/$gistid.git"
        git config user.name "${{ github.actor }}"
        git config user.email "${{ github.actor }}@users.noreply.github.com"
        git add (Split-Path -Path $zip -Leaf)
        git commit -m "added from azure automation"
        git push origin main

        $moduleurl = (gh api gists/$gistid | ConvertFrom-Json).files.'temp.zip'.raw_url

        $getparms = @{
          Name                  = $modulename
          ResourceGroupName     = $resourcegroup
          AutomationAccountName = $account
          ErrorAction           = "Ignore"
        }

        Get-AzAutomationModule @getparms -OutVariable moduleinstance
        return
        if ($moduleinstance.ProvisioningState -eq "Creating") {
          Write-Warning "The $modulename module is still importing into Azure Automation. Waiting until it's finished before moving on..."
          do {
            Start-Sleep 3
            Write-Warning "Waiting..."
          } while ((Get-AzAutomationModule @getparms).ProvisioningState -eq "Creating")
        }

        $parms = @{
          Name                  = $modulename
          ResourceGroupName     = $resourcegroup
          AutomationAccountName = $account
          ContentLinkUri        = $moduleurl
        }

        if ("${{ inputs.default-profile }}") {
          $parms.DefaultProfile = "${{ inputs.default-profile }}"
        }

        if (-not $moduleinstance) {
          $remove = $true
          New-AzAutomationModule @parms
        } else {
          if ("${{ inputs.module-version }}") {
            $parms.ContentLinkVersion = "${{ inputs.module-version }}"
          } else {
            $parms.ContentLinkVersion = "2.0"
          }
          Set-AzAutomationModule @parms
        }

        # It sometimes takes a while...
        do {
          Start-Sleep 5
          Write-Verbose "Module import is in progress.."
        } while ((Get-AzAutomationModule @getparms).ProvisioningState -in "Creating", "RunningImportModuleRunbook", "ContentValidated")

        # Finish and if it's anything other than Available, the import was not successful
        Get-AzAutomationModule @getparms -OutVariable results
        $state = $results.ProvisioningState

        # If it was newly added
        if ($remove) {
          $null = $results | Remove-AzAutomationModule -Force
        }
        if ($state -ne "Available") {
          throw "Provisioning failed with status $state"
        }