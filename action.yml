name: "azautomodule"
branding:
  icon: "terminal"
  color: "blue"
description: "Imports a PowerShell-based GitHub Repo module into Azure Automation"
inputs:
  module-name:
    description: "The name of the module that this action imports. Defaults to the repository name."
    required: false
  module-uri:
    description: "The url to a module zip package. Defaults to GitHub's branch zip."
    required: false
  module-version:
    description: "Specifies the version of the module to which this action updates Automation. If no version is specified and it's required, the action will attempt to figure it out."
    required: false
  resource-group-name:
    description: "Specifies the name of a resource group for which this action imports the module."
    required: true
  automation-account-name:
    description: "The name of the Automation account for which this action imports the module"
    required: true
  default-profile:
    description: "The credentials, account, tenant, and subscription used for communication with Azure."
    required: false
  verbose:
    description: "Show verbose output. Defaults to true."
    required: true
    default: "true"
runs:
  using: "composite"
  steps:
    - name: Install and cache PowerShell modules
      uses: potatoqualitee/psmodulecache@v5.2
      with:
        modules-to-cache: Az.Automation, Az.Accounts
    - id: module
      shell: pwsh
      run: |
        # First check to see if they've logged into Azure
        if (-not (Get-AzContext).Account) {
          throw "Please use the Azure Login GitHub Action to login first. See the azautomodule readme for details."
        }

        # Explicit import before verbose because implicit imports are so noisy
        Import-Module Az.Automation

        if ("${{ inputs.verbose }}" -eq $true) {
          $VerbosePreference = "Continue"
        }

        $branch = $env:GITHUB_REF_NAME
        Write-Output "Currently in branch: $branch"
        $resourcegroup = "${{ inputs.resource-group-name }}"
        $account = "${{ inputs.automation-account-name }}"

        if (-not "${{ inputs.module-name }}") {
          $modulename = $env:GITHUB_REPOSITORY -split "/" | Select-Object -Last 1
        } else {
          $modulename = "${{ inputs.module-name }}"
        }

        if (-not "${{ inputs.module-uri }}") {
          $moduleuri = "https://github.com/$env:GITHUB_REPOSITORY/archive/refs/heads/$branch.zip"
        } else {
          $moduleuri = "${{ inputs.module-uri }}"
        }

        $getparms = @{
          Name                  = $modulename
          ResourceGroupName     = $resourcegroup
          AutomationAccountName = $account
          ErrorAction           = "Ignore"
        }

        Get-AzAutomationModule @getparms -OutVariable moduleinstance


        if ($moduleinstance.ProvisioningState -eq "Creating") {
          Write-Warning "The $modulename module is still importing into Azure Automation. Waiting until it's finished before moving on..."
          do {
            Start-Sleep 3
            Write-Warning "Waiting..."
          } while ((Get-AzAutomationModule @getparms).ProvisioningState -eq "Creating")
        }

        $parms = @{
          Name                  = $modulename
          ResourceGroupName     = $resourcegroup
          AutomationAccountName = $account
          ContentLinkUri        = $moduleuri
        }

        if ("${{ inputs.default-profile }}") {
          $parms.DefaultProfile = "${{ inputs.default-profile }}"
        }

        if (-not $moduleinstance) {
          $remove = $true
          New-AzAutomationModule @parms
        } else {
          if ("${{ inputs.module-version }}") {
            $parms.ContentLinkVersion = "${{ inputs.module-version }}"
          } else {
            $parms.ContentLinkVersion = "2.0"
          }
          Set-AzAutomationModule @parms
        }

        # It sometimes takes a while...
        do {
          Start-Sleep 3
        } while ((Get-AzAutomationModule @getparms).ProvisioningState -in "Creating", "RunningImportModuleRunbook", "ContentValidated")

        # Finish and if it's anythig other than Available, the import was not successful
        Get-AzAutomationModule @getparms -OutVariable results
        $state = $results.ProvisioningState

        # If it was newly added
        if ($remove) {
          $null = $results | Remove-AzAutomationModule -Force
        }
        if ($state -ne "Available") {
          throw "Provisioning failed with status $state"
        }